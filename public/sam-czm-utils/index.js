!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@turf/turf")):"function"==typeof define&&define.amd?define(["@turf/turf"],t):"object"==typeof exports?exports.SamCesiumUtils=t(require("@turf/turf")):e.SamCesiumUtils=t(e["@turf/turf"])}(self,(e=>(()=>{"use strict";var t={691:t=>{t.exports=e}},n={};function i(e){var r=n[e];if(void 0!==r)return r.exports;var a=n[e]={exports:{}};return t[e](a,a.exports,i),a.exports}i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};return(()=>{i.r(r),i.d(r,{default:()=>l});var e=i(691);let t=null;function n(e,n,i){t=i,this.viewer=e,this.options=n||{},this._positions=n.positions,this._height=this.options.height||0,this.bottomImg=n.bottomImg,this.wallImg=n.wallImg,this.splitNum=t.defaultValue(n.splitNum,50),this._positions&&this._positions.length>0&&this.updateTerrainClipData(this._positions)}Object.defineProperties(n.prototype,{show:{get:function(){return this._show},set:function(e){this._show=e,this.viewer.scene.globe.clippingPlanes&&(this.viewer.scene.globe.clippingPlanes.enabled=e),this._switchExcavate(e)}},height:{get:function(){return this._height},set:function(e){this._height=e}}}),n.prototype.updateTerrainClipData=function(e){this.clear(),this.ifAntiClockwise(e)&&e.reverse();let n=[],i=e.length;0!==t.Cartesian3.subtract(e[0],e[1],new t.Cartesian3).x&&(this.excavateMinHeight=9999);for(let r=0;r<i;++r){let a=(r+1)%i,o=t.Cartographic.fromCartesian(e[r]),s=this.viewer.scene.globe.getHeight(o)||o.height;s<this.excavateMinHeight&&(this.excavateMinHeight=s);let l=t.Cartesian3.add(e[r],e[a],new t.Cartesian3);l=t.Cartesian3.multiplyByScalar(l,.5,l);let c=t.Cartesian3.normalize(l,new t.Cartesian3),m=t.Cartesian3.subtract(e[a],l,new t.Cartesian3);0===m.x&&0===m.y&&0===m.z?console.log("有点不在范围内1"):m=t.Cartesian3.normalize(m,m);let u=t.Cartesian3.cross(m,c,new t.Cartesian3);if(0===u.x&&0===u.y&&0===u.z)console.log("有点不在范围内2");else{u=t.Cartesian3.normalize(u,u);let e=new t.Plane(u,0),i=t.Plane.getPointDistance(e,l);n.push(new t.ClippingPlane(u,i))}}const r=new t.ClippingPlaneCollection({planes:n,edgeWidth:0,edgeColor:t.Color.WHITE,enabled:!0,unionClippingRegions:!1});this.viewer.scene.globe.clippingPlanes=r;try{if(window.sjswTileset){const e=new t.ClippingPlaneCollection({planes:n,edgeWidth:1,edgeColor:t.Color.WHITE,modelMatrix:t.Matrix4.inverse(t.Transforms.eastNorthUpToFixedFrame(window.sjswTileset.boundingSphere.center),new t.Matrix4)});window.sjswTileset.clippingPlanes=e}}catch(e){}this._prepareWell(e),this._createWell(this.wellData)},n.prototype.getClipPlanes=function(e){this.ifAntiClockwise(e)&&e.reverse();let n=[],i=e.length;for(let r=0;r<i;++r){let a=(r+1)%i,o=t.Cartesian3.add(e[r],e[a],new t.Cartesian3);o=t.Cartesian3.multiplyByScalar(o,.5,o);let s=t.Cartesian3.normalize(o,new t.Cartesian3),l=t.Cartesian3.subtract(e[a],o,new t.Cartesian3),c=t.Cartesian3.cross(l,s,new t.Cartesian3);c=t.Cartesian3.normalize(c,c),n.push(new t.ClippingPlane.fromPlane(new t.Plane.fromPointNormal(o,c)))}return n},n.prototype.clear=function(){this.viewer.scene.globe.clippingPlanes&&(this.viewer.scene.globe.clippingPlanes.enabled=!1,this.viewer.scene.globe.clippingPlanes.isDestroyed()||this.viewer.scene.globe.clippingPlanes.removeAll()),window?.sjswTileset?.clippingPlanes?.removeAll&&window.sjswTileset.clippingPlanes.removeAll(),this.bottomSurface&&(this.viewer.scene.primitives.remove(this.bottomSurface),delete this.bottomSurface),this.wellWall&&(this.viewer.scene.primitives.remove(this.wellWall),delete this.wellWall),this.viewer.scene.render()},n.prototype._prepareWell=function(e){var n=this.splitNum,i=e.length;if(0!=i){for(var r=this.excavateMinHeight-this.height,a=[],o=[],s=[],l=0;l<i;l++){var c=l==i-1?0:l+1,m=t.Cartographic.fromCartesian(e[l]),u=t.Cartographic.fromCartesian(e[c]),p=[m.longitude,m.latitude],d=[u.longitude,u.latitude];0==l&&(s.push(new t.Cartographic(p[0],p[1])),o.push(t.Cartesian3.fromRadians(p[0],p[1],r)),a.push(t.Cartesian3.fromRadians(p[0],p[1],0)));for(var f=1;f<=n;f++){var h=t.Math.lerp(p[0],d[0],f/n),v=t.Math.lerp(p[1],d[1],f/n);l==i-1&&f==n||(s.push(new t.Cartographic(h,v)),o.push(t.Cartesian3.fromRadians(h,v,r)),a.push(t.Cartesian3.fromRadians(h,v,0)))}}this.wellData={lerp_pos:s,bottom_pos:o,no_height_top:a}}},n.prototype._createWell=function(e){if(Boolean(this.viewer.terrainProvider._layers)){var n=this;this._createBottomSurface(e.bottom_pos),t.sampleTerrainMostDetailed(this.viewer.terrainProvider,e.lerp_pos).then((i=>{for(var r=i.length,a=[],o=0;o<r;o++){var s=t.Cartesian3.fromRadians(i[o].longitude,i[o].latitude,i[o].height);a.push(s)}n._createWellWall(e.bottom_pos,a)}))}else this._createBottomSurface(e.bottom_pos),this._createWellWall(e.bottom_pos,e.no_height_top)},n.prototype._getMinHeight=function(e){for(var t=5e7,n=null,i=0;i<e.length;i++){var r=e[i].z;r<t&&(t=r,n=this._ellipsoidToLonLat(e[i]))}return n.altitude},n.prototype._ellipsoidToLonLat=function(e){var n=this.viewer.scene.globe.ellipsoid,i=new t.Cartesian3(e.x,e.y,e.z),r=n.cartesianToCartographic(i),a=t.Math.toDegrees(r.latitude);return{longitude:t.Math.toDegrees(r.longitude),latitude:a,altitude:r.height}},n.prototype._createBottomSurface=function(e){if(e.length){for(var n=this._getMinHeight(e),i=[],r=0;r<e.length;r++){var a=this._ellipsoidToLonLat(e[r]);i.push(a.longitude),i.push(a.latitude),i.push(n)}var o=new t.PolygonGeometry({polygonHierarchy:new t.PolygonHierarchy(t.Cartesian3.fromDegreesArrayHeights(i)),perPositionHeight:!0,closeBottom:!1}),s=t.PolygonGeometry.createGeometry(o),l=(r=new t.Material({fabric:{type:"Image",uniforms:{image:this.bottomImg}}}),new t.MaterialAppearance({translucent:!1,flat:!0,material:r}));this.bottomSurface=new t.Primitive({geometryInstances:new t.GeometryInstance({geometry:s}),appearance:l,asynchronous:!1}),this.viewer.scene.primitives.add(this.bottomSurface)}},n.prototype._createWellWall=function(e,n){for(var i=this._getMinHeight(e),r=[],a=[],o=0;o<n.length;o++)r.push(this._ellipsoidToLonLat(n[o]).altitude),a.push(i);var s=new t.WallGeometry({positions:n,maximumHeights:r,minimumHeights:a}),l=t.WallGeometry.createGeometry(s),c=new t.Material({fabric:{type:"Image",uniforms:{image:this.wallImg}}}),m=new t.MaterialAppearance({translucent:!1,flat:!0,material:c});this.wellWall=new t.Primitive({geometryInstances:new t.GeometryInstance({geometry:l,attributes:{color:t.ColorGeometryInstanceAttribute.fromColor(t.Color.GREY)},id:"PitWall"}),appearance:m,asynchronous:!1}),this.viewer.scene.primitives.add(this.wellWall)},n.prototype._switchExcavate=function(e){e?(this.viewer.scene.globe.material=t.Material.fromType("WaJue"),this.wellWall.show=!0,this.bottomSurface.show=!0):(this.viewer.scene.globe.material=null,this.wellWall.show=!1,this.bottomSurface.show=!1)},n.prototype._updateExcavateDepth=function(e){this.bottomSurface&&this.viewer.scene.primitives.remove(this.bottomSurface),this.wellWall&&this.viewer.scene.primitives.remove(this.wellWall);for(var n=this.wellData.lerp_pos,i=[],r=n.length,a=0;a<r;a++)i.push(t.Cartesian3.fromRadians(n[a].longitude,n[a].latitude,this.excavateMinHeight-e));this.wellData.bottom_pos=i,this._createWell(this.wellData),this.viewer.scene.primitives.add(this.bottomSurface),this.viewer.scene.primitives.add(this.wellWall)},n.prototype.ifAntiClockwise=function(t){var n=JSON.parse(JSON.stringify(t));n.push(n[0]);var i=e.lineString(n.map(((e,t)=>this.getLatLngFromXZY(e))));return e.booleanClockwise(i)},n.prototype.getLatLngFromXZY=function(e){var n=this.viewer.scene.globe.ellipsoid,i=new t.Cartesian3(e.x,e.y,e.z),r=n.cartesianToCartographic(i),a=t.Math.toDegrees(r.latitude),o=t.Math.toDegrees(r.longitude);return r.height,[o,a]};const a=n;class o{constructor(e){this._modelMatrix=e}update(e){const t=s(e,this._modelMatrix);e.commandList.push(t)}isDestroyed(){return!1}}let s;const l={samCzm:class{constructor({viewer:e,Cesium:t}){this.viewer=e,this.Cesium=t}initViewer({id:e,initCamera:t,viewerOptions:n={}}){this.Cesium.Ion.defaultAccessToken="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJjMzM3OGE5Yi1lYjc5LTRhNzQtYWFjMC04M2M2MTY3YjFjM2YiLCJpZCI6NDEzMTIsImlhdCI6MTcwMzIwODY4MH0.Hda2inmYARoq6khHSp68tXlk0vPNfNEsenzYLFVLk_k";const i=new this.Cesium.Viewer(e,{infoBox:!1,fullscreenButton:!1,homeButton:!1,sceneModePicker:!1,navigationHelpButton:!1,animation:n.animation||!1,timeline:n.timeline||!1,fullscreenButtion:!1,vrButton:!1,selectionIndicator:!1,baseLayerPicker:!1,baseLayer:!1,scene3DOnly:!0});this.Cesium.IonImageryProvider.fromAssetId(2).then((e=>{i.imageryLayers.addImageryProvider(e)})),i.scene.globe.depthTestAgainstTerrain=!0,i._cesiumWidget._creditContainer.style.display="none",i.resolutionScale=1,window.viewer=i,t&&i.scene.camera.flyToBoundingSphere(new this.Cesium.BoundingSphere(this.Cesium.Cartesian3.fromDegrees(118.79304711609575,32.07511800768333),3e3),{offset:new this.Cesium.HeadingPitchRoll(0,this.Cesium.Math.toRadians(-30),0),duration:1}),window.pickPointList=[];const r=new this.Cesium.ScreenSpaceEventHandler(i.canvas);r.setInputAction((e=>{const t=i.scene.pickPosition(e.position);console.log("Cartesian3: %o",t);const n=this.Cesium.Cartographic.fromCartesian(t);console.log("Cartographic: %o",{lat:this.Cesium.Math.toDegrees(n.latitude),lng:this.Cesium.Math.toDegrees(n.longitude),height:n.height}),window.pickPointList.push(t)}),this.Cesium.ScreenSpaceEventType.LEFT_CLICK),r.setInputAction((e=>{window.pickPointList=[]}),this.Cesium.ScreenSpaceEventType.RIGHT_CLICK),this.viewer=i}removaEntitiesAndPrimitivesByName(e){this.getEntitiesByName(e).forEach((e=>{this.viewer.entities.remove(e)})),this.viewer.scene.primitives._primitives.filter((t=>t.name===e)).forEach((e=>{this.viewer.scene.primitives.remove(e)}))}getEntitiesByName(e){return this.viewer.entities._entities._array.filter((t=>t.name===e))}addWallGeojson({wallList:e,maximumHeights:t,minimumHeights:n,imgUrl:i,dynamicDir:r,repeat:a}){const o=e.map((e=>(e.push(e[0]),new this.Cesium.GeometryInstance({geometry:new this.Cesium.WallGeometry({positions:e,maximumHeights:e.map((()=>t)),minimumHeights:e.map((()=>n)),vertexFormat:this.Cesium.MaterialAppearance.VERTEX_FORMAT})})))),s=new this.Cesium.Primitive({geometryInstances:o,appearance:new this.Cesium.MaterialAppearance({material:new this.Cesium.Material({fabric:{type:"DynamicWall"+r,uniforms:{image:i,color:this.Cesium.Color.fromCssColorString("#3a5e88"),repeat:a||new this.Cesium.Cartesian2(4,1),speed:1},source:`\n              czm_material czm_getMaterial(czm_materialInput materialInput) {\n                  czm_material material = czm_getDefaultMaterial(materialInput);\n                  vec2 st = materialInput.st * repeat;\n                  ${"chuiZhi"==r?"vec4 colorImage = texture(image, vec2((1. - fract(st.t - speed * czm_frameNumber * 0.005)), st.t));":"vec4 colorImage = texture(image, vec2((1. - fract(st.s - speed * czm_frameNumber * 0.005)), st.t));"}\n                  vec4 fragColor;\n                  fragColor.rgb = color.rgb / 1.0;\n                  fragColor = czm_gammaCorrect(fragColor); // 伽马校正\n                  material.alpha = colorImage.a * color.a  * 1.4;\n                  material.diffuse = color.rgb;\n                  material.emission = fragColor.rgb;\n                  return material;\n              }\n          `}})})});s.name="DynamicWall",this.viewer.scene.primitives.add(s)}getBoundingSphereFromCartesian3List(t){function n(e,t){const n=t.Cartographic.fromCartesian(e);return{lat:t.Math.toDegrees(n.latitude),lng:t.Math.toDegrees(n.longitude),height:n.height}}const i=t.map((e=>[n(e,this.Cesium).lng,n(e,this.Cesium).lat])),r=e.bbox(e.featureCollection(i.map((t=>e.point([t[0],t[1]]))))),a=e.point([r[0],r[1]]),o=e.point([r[2],r[3]]),s=e.distance(a,o,{units:"kilometers"}),l=e.midpoint(a,o);return new this.Cesium.BoundingSphere(this.Cesium.Cartesian3.fromDegrees(l.geometry.coordinates[0],l.geometry.coordinates[1]),1e3*s/2)}lineFlowInit(e,t){let n=function(e,t){let n=[];for(let i=0;i<t;i++){let t=e[0]+.07*Math.random()*(Math.random()>.5?1:-1),i=e[1]+.07*Math.random()*(Math.random()>.5?1:-1);n.push([t,i])}return n}(e,t),i=[];n.forEach((e=>{let t=e[0],n=e[1],r=new this.Cesium.Cartesian3.fromDegrees(t,n,0),a=5e3*Math.random(),o=new this.Cesium.Cartesian3.fromDegrees(t,n,a),s=[];s.push(r),s.push(o),i=new this.Cesium.GeometryInstance({geometry:new this.Cesium.PolylineGeometry({positions:s,width:3,vertexFormat:this.Cesium.PolylineMaterialAppearance.VERTEX_FORMAT})}),this.viewer.scene.primitives.add(new this.Cesium.Primitive({geometryInstances:i,appearance:new this.Cesium.PolylineMaterialAppearance({material:new this.Cesium.Material({fabric:{type:"upLine",uniforms:{color:new this.Cesium.Color.fromCssColorString("#fe01fa"),speed:6*Math.random(),percent:.2,gradient:.01},source:"\n                          czm_material czm_getMaterial(czm_materialInput materialInput){\n                              czm_material material = czm_getDefaultMaterial(materialInput);\n                              vec2 st = materialInput.st;\n                              float t =fract(czm_frameNumber * speed / 1000.0);\n                              t *= (1.0 + percent);\n                              float alpha = smoothstep(t- percent, t, st.s) * step(-t, -st.s);\n                              alpha += gradient;\n                              material.diffuse = color.rgb;\n                              material.alpha = alpha;\n                              return material;\n                            }"}})})}))}))}parabolaFlowLine({center:e,positions:t,height:n=5e3,flowNumInEachLine:i}){t.forEach((t=>{let r=function(e,t,n=0,i=50,r){let a=[];n=Math.max(+n,100),i=Math.max(+i,50);let o=Math.abs(e[0]-t[0]),s=Math.abs(e[1]-t[1]),l=Math.max(o,s),c=l/i;if(o>s){let o=(t[1]-e[1])/i;e[0]-t[0]>0&&(c=-c);for(let t=0;t<i;t++){let i=n-4*Math.pow(-.5*l+Math.abs(c)*t,2)*n/Math.pow(l,2),s=e[0]+c*t,m=e[1]+o*t,u=new r.Cartesian3.fromDegrees(s,m,i);a.push(u)}}else{let o=(t[0]-e[0])/i;e[1]-t[1]>0&&(c=-c);for(let t=0;t<i;t++){let i=n-4*Math.pow(-.5*l+Math.abs(c)*t,2)*n/Math.pow(l,2),s=e[0]+o*t,m=e[1]+c*t,u=new r.Cartesian3.fromDegrees(s,m,i);a.push(u)}}return a}(e,t,n,50,this.Cesium);for(let e=0;e<i;e++){let e=new this.Cesium.GeometryInstance({geometry:new this.Cesium.PolylineGeometry({positions:r,width:3,vertexFormat:this.Cesium.PolylineMaterialAppearance.VERTEX_FORMAT})});this.viewer.scene.primitives.add(new this.Cesium.Primitive({geometryInstances:e,appearance:new this.Cesium.PolylineMaterialAppearance({material:new this.Cesium.Material({fabric:{type:"flowParabolaLine",uniforms:{color:new this.Cesium.Color.fromCssColorString("#fe01fa"),speed:6*Math.random(),percent:.2,gradient:.01},source:"\n                          czm_material czm_getMaterial(czm_materialInput materialInput){\n                              czm_material material = czm_getDefaultMaterial(materialInput);\n                              vec2 st = materialInput.st;\n                              float t =fract(czm_frameNumber * speed / 1000.0);\n                              t *= (1.0 + percent);\n                              float alpha = smoothstep(t- percent, t, st.s) * step(-t, -st.s);\n                              alpha += gradient;\n                              material.diffuse = color.rgb;\n                              material.alpha = alpha;\n                              return material;\n                            }"}})})}))}this.viewer.entities.add({polyline:{positions:r,material:new this.Cesium.Color.fromCssColorString("rgba(254,1,250,0.32)")}})}))}lightenEillposid({position:e,radii:t,color:n,speed:i}){const r=this.Cesium.Transforms.eastNorthUpToFixedFrame(e),a=new this.Cesium.Cartesian3(0,0,0),o=new this.Cesium.EllipsoidGeometry({radii:t,vertexFormat:this.Cesium.VertexFormat.POSITION_AND_ST}),s=this.Cesium.EllipsoidGeometry.createGeometry(o);this.viewer.scene.primitives.add(new this.Cesium.Primitive({asynchronous:!1,geometryInstances:new this.Cesium.GeometryInstance({geometry:s,modelMatrix:this.Cesium.Matrix4.multiplyByTranslation(r,a,new this.Cesium.Matrix4),id:"ellipsoid"}),appearance:new this.Cesium.EllipsoidSurfaceAppearance({material:new this.Cesium.Material({fabric:{type:"lightenEillposid",uniforms:{color:n,speed:i},source:"\n                        uniform vec4 color;\n                        uniform float speed;\n\n                        #define pi 3.1415926535\n                        #define PI2RAD 0.01745329252\n                        #define TWO_PI (2. * PI)\n\n                        float rands(float p){\n                        return fract(sin(p) * 10000.0);\n                        }\n\n                        float noise(vec2 p){\n                        float time = fract( czm_frameNumber * speed / 1000.0);\n                        float t = time / 20000.0;\n                        if(t > 1.0) t -= floor(t);\n                        return rands(p.x * 14. + p.y * sin(t) * 0.5);\n                        }\n\n                        vec2 sw(vec2 p){\n                        return vec2(floor(p.x), floor(p.y));\n                        }\n\n                        vec2 se(vec2 p){\n                        return vec2(ceil(p.x), floor(p.y));\n                        }\n\n                        vec2 nw(vec2 p){\n                        return vec2(floor(p.x), ceil(p.y));\n                        }\n\n                        vec2 ne(vec2 p){\n                        return vec2(ceil(p.x), ceil(p.y));\n                        }\n\n                        float smoothNoise(vec2 p){\n                        vec2 inter = smoothstep(0.0, 1.0, fract(p));\n                        float s = mix(noise(sw(p)), noise(se(p)), inter.x);\n                        float n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n                        return mix(s, n, inter.y);\n                        }\n\n                        float fbm(vec2 p){\n                        float z = 2.0;\n                        float rz = 0.0;\n                        vec2 bp = p;\n                        for(float i = 1.0; i < 6.0; i++){\n                            rz += abs((smoothNoise(p) - 0.5)* 2.0) / z;\n                            z *= 2.0;\n                            p *= 2.0;\n                        }\n                        return rz;\n                        }\n\n                        czm_material czm_getMaterial(czm_materialInput materialInput)\n                        {\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        vec2 st = materialInput.st;\n                        vec2 st2 = materialInput.st;\n                        float time = fract( czm_frameNumber * speed / 1000.0);\n                        if (st.t < 0.5) {\n                            discard;\n                        }\n                        st *= 4.;\n                        float rz = fbm(st);\n                        st /= exp(mod( time * 2.0, pi));\n                        rz *= pow(15., 0.9);\n                        vec4 temp = vec4(0);\n                        temp = mix( color / rz, vec4(color.rgb, 0.1), 0.2);\n                        if (st2.s < 0.05) {\n                            temp = mix(vec4(color.rgb, 0.1), temp, st2.s / 0.05);\n                        }\n                        if (st2.s > 0.95){\n                            temp = mix(temp, vec4(color.rgb, 0.1), (st2.s - 0.95) / 0.05);\n                        }\n                        material.diffuse = temp.rgb;\n                        material.alpha = temp.a * 3.0;\n                        return material;\n                        }\n                    "}})})}))}kuoSanYuan({latlng:e,color:t,radius:n,speed:i,height:r}){const a=new this.Cesium.GeometryInstance({geometry:new this.Cesium.CircleGeometry({center:this.Cesium.Cartesian3.fromDegrees(e[0],e[1],e[2]),radius:n,height:r})}),o=new this.Cesium.Primitive({geometryInstances:a,appearance:new this.Cesium.MaterialAppearance({material:new this.Cesium.Material({fabric:{type:"KuoSanYuan",uniforms:{color:this.Cesium.Color.fromCssColorString(t),speed:i},source:"\n                      uniform vec4 color;\n                      uniform float speed;\n                      float circle(vec2 uv, float r, float blur) {\n                        float d = length(uv) * 1.0; /* 2.0 */\n                        float c = smoothstep(r+blur, r, d);\n                        return c;\n                      }\n                      czm_material czm_getMaterial(czm_materialInput materialInput)\n                      {\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        vec2 st = materialInput.st - 0.5;\n                        material.diffuse = 2.8 * color.rgb;\n                        material.emission = vec3(0);\n                        float t = fract(czm_frameNumber * speed / 1000.0);\n                        float s = 0.3;\n                        float radius1 = smoothstep(.0, s, t) * 0.5;\n                        float alpha1 = circle(st, radius1, 0.01) * circle(st, radius1, -0.01);\n                        float alpha2 = circle(st, radius1, 0.01 - radius1) * circle(st, radius1, 0.01);\n                        float radius2 = 0.5 + smoothstep(s, 1.0, t) * 0.5;\n                        float alpha3 = circle(st, radius1, radius2 + 0.01 - radius1) * circle(st, radius1, -0.01);\n                        material.alpha = smoothstep(1.0, s, t) * (alpha1 + alpha2*0.1 + alpha3*0.1);\n                        material.alpha *= color.a ;\n                        return material;\n                      }\n                  "}})})});this.viewer.scene.primitives.add(o)}addRadar1({latlng:e,color:t,radius:n,speed:i,height:r}){const a=new this.Cesium.GeometryInstance({geometry:new this.Cesium.CircleGeometry({center:this.Cesium.Cartesian3.fromDegrees(e[0],e[1],e[2]),radius:n,height:r})}),o=new this.Cesium.Primitive({geometryInstances:a,appearance:new this.Cesium.MaterialAppearance({material:new this.Cesium.Material({fabric:{type:"radar1",uniforms:{color:this.Cesium.Color.fromCssColorString(t),speed:i},source:"\n                      uniform vec4 color;\n                      uniform float speed;\n                      vec2 center = vec2(0.,0.);\n                      float radius = 0.45;\n                      // 旋转点\n                      vec2 rotatePoint(float angle,vec2 p)\n                        {\n                          float s = sin(angle);\n                          float c = cos(angle);\n                          // rotate point\n                          float xnew = p.x * c - p.y * s;\n                          float ynew = p.x * s + p.y * c;\n                          p.x = xnew;\n                          p.y = ynew;\n                          return p;\n                        }\n                      // 计算点到线的距离\n                      float LineToPointDistance2D( vec2 b, vec2 p)\n                        {\n                            vec2 pa = p;\n                            vec2 ba = b;\n                        \n                            float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n                        \n                            return length( pa - ba*h );\n                        }\n                        \n                      float angleVec(vec2 a_, vec2 b_) \n                        {\n                            vec3 a = vec3(a_, 0);\n                            vec3 b = vec3(b_, 0);\n                             float dotProd = dot(a,b); \n                             vec3 crossprod = cross(a,b);\n                             float crossprod_l = length(crossprod);\n                             float lenProd = length(a)*length(b);\n                             float cosa = dotProd/lenProd;\n                             float sina = crossprod_l/lenProd;\n                             float angle = atan(sina, cosa);\n\n                             if(dot(vec3(0,0,1), crossprod) < 0.0) \n                                angle=90.0;\n                             return (angle * (180.0 / czm_pi));\n                        }\n                 \n                      czm_material czm_getMaterial(czm_materialInput materialInput)\n                      {\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        vec2 st = materialInput.st - 0.5;\n                        // st的范围是 -0.5到0.5  所以半径是 0.5\n                        vec4 colorTemp = color;\n                        colorTemp.a = 0.;\n                        material.diffuse = vec3(0.);\n                        material.emission = vec3(0);\n                        float t = -czm_frameNumber * speed / 500.0;\n                        // 边线宽度\n                        float circleWitdh = radius * 0.02;\n                        // 扫描线宽度\n                        float lineWitdh = circleWitdh * 0.5;\n                        // 点到圆心的距离\n                        float distanceToCenter = distance(vec2(0.),st);\n                        // 点到圆边的距离  去除边线的宽度\n                        float disPointToCircle = abs(distanceToCenter - 0.45 - circleWitdh);\n                        //画圆\n                        if (disPointToCircle < circleWitdh)\n                        {\n                            float val = 1.0-(disPointToCircle/circleWitdh);\n                            // +0.5后，黑边可以去除，提高颜色亮度\n                            colorTemp *= (val + 0.5);\n                            colorTemp.a = val;\n                        }\n                        // 旋转线\n                        vec2 lineEnd =  vec2(0.,0.45); // 线终点的初始位置\n                        float angle = t;\n                        lineEnd = rotatePoint(angle,lineEnd);\n                        // 画线\n                        float distPointToLine = LineToPointDistance2D(lineEnd,st);\n                        if (distPointToLine<lineWitdh)\n                        { \n                            float val = 1.0-distPointToLine/lineWitdh;\n                            colorTemp*=(val+0.5);\n                            colorTemp.a = val;\n                             \n                        }\n                        float angleStela = 180.0;\n                        // 画动态阴影\n                        //Draw Stela\n                        // 计算当前st和当前扫描线的夹角\n                          float angleStelaToApply = angleVec(normalize(lineEnd-center),normalize(st-center));\n                          // 当前st和线夹角小于180的 赋予扫描颜色\n                          if (angleStelaToApply<angleStela && distanceToCenter<radius-circleWitdh/2.0 + 0.008)\n                          {\n                            float factorAngle = 1.0-angleStelaToApply/angleStela;\n                            float removeAngle = 0.0; // 在这180度中,从尾部去掉这些角度不上色\n                            float finalFactorAngle = (factorAngle*0.5)-removeAngle;\n                            colorTemp*=(finalFactorAngle + 0.5);\n                            colorTemp.a = finalFactorAngle *2.;\n                          }\n                        material.diffuse = colorTemp.rgb;\n                        material.alpha = colorTemp.a;\n                        return material;\n                      }\n                  "}})})});this.viewer.scene.primitives.add(o)}addCircleWaterExpand({latlng:e,color:t,radius:n,speed:i,height:r,count:a=4}){const o=new this.Cesium.GeometryInstance({geometry:new this.Cesium.CircleGeometry({center:this.Cesium.Cartesian3.fromDegrees(e[0],e[1],e[2]),radius:n,height:r})}),s=new this.Cesium.Primitive({geometryInstances:o,appearance:new this.Cesium.MaterialAppearance({material:new this.Cesium.Material({fabric:{type:"CircleWaterExpand",uniforms:{color:this.Cesium.Color.fromCssColorString(t),speed:i,count:a,gradient:.2},source:"\n                        uniform vec4 color;\n                        uniform float speed;\n                        uniform float count;\n                        uniform float gradient;\n    \n                        czm_material czm_getMaterial(czm_materialInput materialInput)\n                        {\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        material.diffuse = 1.5 * color.rgb;\n                        vec2 st = materialInput.st;\n                        float dis = distance(st, vec2(0.5, 0.5));\n                        float per = fract(czm_frameNumber * speed / 1000.0);\n                        if(count == 1.0){\n                            if(dis > per * 0.5){\n                            discard;\n                            }else {\n                            material.alpha = color.a  * dis / per / 2.0;\n                            }\n                        } else {\n                            vec3 str = materialInput.str;\n                            if(abs(str.z)  > 0.001){\n                            discard;\n                            }\n                            if(dis > 0.5){\n                            discard;\n                            } else {\n                            float perDis = 0.5 / count;\n                            float disNum;\n                            float bl = 0.0;\n                            for(int i = 0; i <= 999; i++){\n                                if(float(i) <= count){\n                                disNum = perDis * float(i) - dis + per / count;\n                                if(disNum > 0.0){\n                                    if(disNum < perDis){\n                                    bl = 1.0 - disNum / perDis;\n                                    }\n                                    else if(disNum - perDis < perDis){\n                                    bl = 1.0 - abs(1.0 - disNum / perDis);\n                                    }\n                                    material.alpha = pow(bl,(1.0 + 10.0 * (1.0 - gradient)));\n                                }\n                                }\n                            }\n                            }\n                        }\n                        return material;\n                        }\n                  "}})})});this.viewer.scene.primitives.add(s)}addWeightCircleExpand({latlng:e,color:t,radius:n,speed:i,height:r}){const a=new this.Cesium.GeometryInstance({geometry:new this.Cesium.CircleGeometry({center:this.Cesium.Cartesian3.fromDegrees(e[0],e[1],e[2]),radius:n,height:r})}),o=new this.Cesium.Primitive({geometryInstances:a,appearance:new this.Cesium.MaterialAppearance({material:new this.Cesium.Material({fabric:{type:"CircleWaterExpand",uniforms:{color:this.Cesium.Color.fromCssColorString(t),speed:i},source:"\n                        uniform vec4 color;\n                        uniform float speed;\n\n                        vec3 circlePing(float r, float innerTail,  float frontierBorder, float timeResetSeconds,  float radarPingSpeed,  float fadeDistance){\n                        float t = fract(czm_frameNumber * speed / 1000.0);\n                        float time = mod(t, timeResetSeconds) * radarPingSpeed;\n                        float circle;\n                        circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);\n                        circle *= smoothstep(fadeDistance, 0.0, r);\n                        return vec3(circle);\n                        }\n\n                        czm_material czm_getMaterial(czm_materialInput materialInput){\n                        czm_material material = czm_getDefaultMaterial(materialInput);\n                        vec2 st = materialInput.st * 2.0  - 1.0 ;\n                        vec2 center = vec2(0.);\n                        float time = fract(czm_frameNumber * speed / 1000.0);\n                        vec3 flagColor;\n                        float r = length(st - center) / 4.;\n                        flagColor += circlePing(r, 0.25, 0.025, 4.0, 0.3, 1.0) * color.rgb;\n                        material.alpha = length(flagColor);\n                        material.diffuse = flagColor.rgb;\n                        return material;\n                        }\n                  "}})})});this.viewer.scene.primitives.add(o)}getFogPostProcess(e,t){return new this.Cesium.PostProcessStage({fragmentShader:"\n  uniform sampler2D colorTexture;\n  uniform sampler2D depthTexture;\n  uniform float alpha;\n  uniform float height;\n  uniform vec3 oneOverRadii;\n  uniform vec3 oneOverRadiiSquared;\n  uniform float centerToleranceSquared;\n  uniform float EPSILON12;\n  uniform float earthRadius;\n\n\n  in vec2 v_textureCoordinates;\n  out vec4 glColor;\n\n  vec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n  }\n  float getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n  }\n\n\n  vec3 getWorldCoordinateFromDepth(in vec4 currD){\n    float depth = czm_unpackDepth(currD);\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\n    vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;\n    vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;\n    return worldCoordinate;\n  }\n\n  float magnitude(in vec3 v){\n    return sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n  }\n\n  // 沿大地表面法线缩放提供的笛卡尔位置,使其位于该椭球体的表面上\n  vec3 scaleToGeodeticSurface(in vec3 cartesian){\n    float positionX = cartesian.x;\n    float positionY = cartesian.y;\n    float positionZ = cartesian.z;\n    float x2 = cartesian.x * cartesian.x * oneOverRadii.x * oneOverRadii.x;\n    float y2 = cartesian.y * cartesian.y * oneOverRadii.y * oneOverRadii.y;\n    float z2 = cartesian.z * cartesian.z * oneOverRadii.z * oneOverRadii.z;\n\n    float squaredNorm = x2 + y2 + z2;\n    float ratio = sqrt(1.0 / squaredNorm);\n    vec3 intersection = cartesian * ratio;\n\n    float oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n    float oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n    float oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n    vec3 gradient = vec3(intersection.x * oneOverRadiiSquaredX * 2.0,intersection.y * oneOverRadiiSquaredY * 2.0,intersection.z * oneOverRadiiSquaredZ * 2.0);\n\n    float lambda = ((1.0 - ratio) * magnitude(cartesian) ) / (0.5 * magnitude(gradient));\n    float correction = 0.0;\n    float func = 0.0;\n    float denominator = 0.0;\n    float xMultiplier = 0.0;\n    float yMultiplier = 0.0;\n    float zMultiplier = 0.0;\n    float xMultiplier2 = 0.0;\n    float yMultiplier2 = 0.0;\n    float zMultiplier2 = 0.0;\n    float xMultiplier3 = 0.0;\n    float yMultiplier3 = 0.0;\n    float zMultiplier3 = 0.0;\n    do {\n        lambda -= correction;\n\n        xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n        yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n        zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n        xMultiplier2 = xMultiplier * xMultiplier;\n        yMultiplier2 = yMultiplier * yMultiplier;\n        zMultiplier2 = zMultiplier * zMultiplier;\n\n        xMultiplier3 = xMultiplier2 * xMultiplier;\n        yMultiplier3 = yMultiplier2 * yMultiplier;\n        zMultiplier3 = zMultiplier2 * zMultiplier;\n\n        float func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n        float denominator =\n          x2 * xMultiplier3 * oneOverRadiiSquaredX +\n          y2 * yMultiplier3 * oneOverRadiiSquaredY +\n          z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n        float derivative = -2.0 * denominator;\n\n        correction = func / derivative;\n    } while (abs(func) > EPSILON12);\n    return vec3(positionX * xMultiplier, positionY * yMultiplier, positionZ * zMultiplier);\n  }\n\n  vec3 multiplyComponents(in vec3 left,in vec3 right){\n    return vec3(left.x * right.x, left.y * right.y, left.z * right.z);\n  }\n\n\n  // 将世界坐标转为经纬度高度\n  vec3 getCartographicFromCartesian3(in vec3 cartesian){\n    vec3 p = scaleToGeodeticSurface(cartesian);\n    vec3 n = multiplyComponents(p,oneOverRadiiSquared);\n    n = normalize(n);\n    vec3 h = cartesian - p;\n\n    float longitude = atan(n.y, n.x);\n    float latitude = asin(n.z);\n    float height = sign(dot(h, cartesian)) * magnitude(h);\n\n    return vec3(longitude,latitude,height);\n  }\n\n  // 计算每个像素点的高度 通过计算相机所在位置的地球半径作为每个点的地球半径,然后用每个点的length减去半径得到近似的高度\n  float getHeight(in vec4 currD){\n    // 传入每个点的世界坐标\n    float altitude = 0.0;\n    float depth = czm_unpackDepth(currD);\n    if (depth == 0.0) {\n      altitude = czm_infinity;\n    }\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\n    float distance = -eyeCoordinate.z / eyeCoordinate.w;\n    vec4 worldCoordinate4 = czm_inverseView * eyeCoordinate;\n    vec3 worldCoordinate = worldCoordinate4.xyz / worldCoordinate4.w;\n    altitude = length(worldCoordinate.xyz) - earthRadius;\n    return altitude;\n  }\n\n  void main(){\n    vec4 color = texture(colorTexture, v_textureCoordinates);\n    vec4 currD = texture(depthTexture, v_textureCoordinates);\n    if(currD.r>=1.0){\n      glColor = color;\n      return;\n    }\n    // 此方法有问题 会闪烁\n    float depth = getDepth(currD);\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec4 positionWC = czm_inverseView * positionEC;\n    // 获取当前点的高度\n    // vec3 positionWC = getWorldCoordinateFromDepth(currD);\n    vec3 cartographic = getCartographicFromCartesian3(vec3(positionWC.x,positionWC.y,positionWC.z));\n    // 高度加了10之后 就不闪烁了\n    float pointHeight = cartographic.z + 10.;\n    // 当前点高度越高,雾浓度越小,高度达到设定高度,雾浓度为0,同时乘以深度,距离越远,浓度越大\n    float fog =  (height/pointHeight - 1.);\n    fog = clamp(fog, 0.0, 1.0);\n    glColor = mix(color,vec4(1.0,1.,1.,1),fog*alpha);\n\n  }",uniforms:{alpha:e,height:t,oneOverRadii:this.Cesium.Ellipsoid.WGS84.oneOverRadii,oneOverRadiiSquared:this.Cesium.Ellipsoid.WGS84.oneOverRadiiSquared,centerToleranceSquared:this.Cesium.Ellipsoid.WGS84._centerToleranceSquared,EPSILON12:this.Cesium.Math.EPSILON12,earthRadius:()=>{const e=this.Cesium.Cartesian3.magnitude(this.viewer.camera.positionWC)-this.viewer.camera.positionCartographic.height;return console.log(e),e}}})}getRainPostProcess(){return new this.Cesium.PostProcessStage({fragmentShader:"\n  uniform sampler2D colorTexture;\n  uniform sampler2D depthTexture;\n  in vec2 v_textureCoordinates;\n  out vec4 glColor;\n  vec4 toEye(in vec2 uv, in float depth){\n      // 将纹理坐标从0-1 转换到-1 到 1\n      vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n      // 将裁剪坐标转换为眼睛坐标\n      vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n      posInCamera =posInCamera / posInCamera.w;\n      return posInCamera;\n  }\n  float getDepth(in vec4 depth){\n      float z_window = czm_unpackDepth(depth);\n      z_window = czm_reverseLogDepth(z_window);\n      float n_range = czm_depthRange.near;\n      float f_range = czm_depthRange.far;\n      return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n  }\n  vec3 guussColor(vec2 uv){\n      vec2 pixelSize = 1.0 / czm_viewport.zw;\n      float dx0 = -pixelSize.x;\n      float dy0 = -pixelSize.y;\n      float dx1 = pixelSize.x;\n      float dy1 = pixelSize.y;\n      vec4 gc = (\n      texture(colorTexture, uv)+\n      texture(colorTexture, uv + vec2(dx0, dy0)) +\n      texture(colorTexture, uv + vec2(0.0, dy0)) +\n      texture(colorTexture, uv + vec2(dx1, dy0)) +\n      texture(colorTexture, uv + vec2(dx0, 0.0)) +\n      texture(colorTexture, uv + vec2(dx1, 0.0)) +\n      texture(colorTexture, uv + vec2(dx0, dy1)) +\n      texture(colorTexture, uv + vec2(0.0, dy1)) +\n      texture(colorTexture, uv + vec2(dx1, dy1))\n      ) * (1.0 / 9.0);\n      return gc.rgb;\n  }\n  void main(){\n      // mat4 dither = mat4(\n      //     0,       0.5,    0.125,  0.625,\n      //     0.75,    0.25,   0.875,  0.375,\n      //     0.1875,  0.6875, 0.0625, 0.5625,\n      //     0.9375,  0.4375, 0.8125, 0.3125\n      // );\n      // int sampleCoordX = int(mod((gl_FragCoord.x * v_textureCoordinates.x),4.0));\n      // int sampleCoordY = int(mod((gl_FragCoord.y * v_textureCoordinates.y),4.0));\n      float offset = 0.0;\n\n\n      vec4 color = texture(colorTexture, v_textureCoordinates);\n      vec4 currD = texture(depthTexture, v_textureCoordinates);\n      // glColor = currD;\n      // return;\n      // 对于深度大于1.0，即距离相机很远的点，应用其本身的颜色\n      if(currD.r>=1.0){\n          glColor = color;\n          return;\n      }\n      float depth = getDepth(currD);\n      // glColor = vec4(depth,0.0,0.0,1.0);\n      // return;\n\n\n      vec4 positionEC = toEye(v_textureCoordinates, depth);\n      vec3 dx = dFdx(positionEC.xyz);\n      vec3 dy = dFdy(positionEC.xyz);\n      vec3 normal = normalize(cross(dx,dy));\n\n      vec4 positionWC = normalize(czm_inverseView * positionEC);\n      vec3 normalWC = normalize(czm_inverseViewRotation * normal);\n      float fotNumWC = dot(positionWC.xyz,normalWC);\n      if(fotNumWC<=0.5){\n          glColor = color;\n          return;\n      }\n\n\n\n\n\n      // float dotNum = dot(normal,vec3(0.0,1.0,0.0));\n      // glColor = mix(color,vec4(1.0),dotNum*0.8);\n      // return;\n\n      vec3 viewDir = normalize(positionEC.xyz);\n      vec3 reflectDir = reflect(viewDir, normal);\n      // vec3 viewReflectDir = czm_viewRotation * reflectDir;\n      vec3 viewReflectDir = reflectDir;\n\n\n      float step = 0.05;\n      int stepNum = int(20.0 / step);\n      vec3 pos;\n      vec3 albedo;\n      bool jd = false;\n      for(int i = 1;i <= 400;i++)\n      {\n          float delta = step * float(i) + offset;\n          pos = positionEC.xyz + viewReflectDir * delta;\n          float d = -pos.z;\n\n          vec4 tmp = czm_projection * vec4(pos,1.0);\n          vec3 screenPos = tmp.xyz / tmp.w;\n          vec2 uv = vec2(screenPos.x, screenPos.y) * 0.5 + vec2(0.5, 0.5);\n\n          if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0){\n              float dd = getDepth(texture(depthTexture, uv));\n              vec4 jzc = toEye(uv, dd);\n              dd = -jzc.z;\n              if(d>dd){\n                  if(abs(abs(d) - abs(dd)) <=step){\n                      jd = true;\n                      // albedo = texture(colorTexture, uv).rgb;\n                      albedo = guussColor(uv);\n                  }\n                  break;\n              }\n          }\n      }\n      if(jd){\n          glColor = vec4(mix(color.xyz,albedo,0.5),1.0);\n      }else{\n          glColor = color;\n      }\n  }\n  ",uniforms:{}})}getRainFlyPostProcess(){return new this.Cesium.PostProcessStage({fragmentShader:"#version 300 es \n            uniform sampler2D colorTexture;\n            in vec2 v_textureCoordinates;\n            out vec4 fragColor;\n            uniform float tiltAngle;\n            uniform float rainSize;\n            uniform float rainSpeed;\n            float hash(float x) {\n                return fract(sin(x * 133.3) * 13.13);\n            }\n            void main(void) {\n                float time = czm_frameNumber / rainSpeed;\n                vec2 resolution = czm_viewport.zw;\n                vec2 uv = (gl_FragCoord.xy * 2. - resolution.xy) / min(resolution.x, resolution.y);\n                vec3 c = vec3(.6, .7, .8);\n                float a = tiltAngle;\n                float si = sin(a), co = cos(a);\n                uv *= mat2(co, -si, si, co);\n                uv *= length(uv + vec2(0, 4.9)) * rainSize + 1.;\n                float v = 1. - sin(hash(floor(uv.x * 100.)) * 2.);\n                float b = clamp(abs(sin(20. * time * v + uv.y * (5. / (2. + v)))) - .95, 0., 1.) * 20.;\n                c *= v * b;\n                fragColor = mix(texture(colorTexture, v_textureCoordinates), vec4(c, 1), .2);\n            }\n            ",uniforms:{tiltAngle:()=>.6,rainSize:()=>.3,rainSpeed:()=>120}})}getSnowCoverPostProcess(e){return new this.Cesium.PostProcessStage({fragmentShader:"\n  uniform sampler2D colorTexture;\n  uniform sampler2D depthTexture;\n  uniform float alpha;\n  in vec2 v_textureCoordinates;\n  out vec4 glColor;\n\n  vec4 toEye(in vec2 uv, in float depth){\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n    posInCamera =posInCamera / posInCamera.w;\n    return posInCamera;\n  }\n  float getDepth(in vec4 depth){\n    float z_window = czm_unpackDepth(depth);\n    z_window = czm_reverseLogDepth(z_window);\n    float n_range = czm_depthRange.near;\n    float f_range = czm_depthRange.far;\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n  }\n  void main(){\n    vec4 color = texture(colorTexture, v_textureCoordinates);\n    vec4 currD = texture(depthTexture, v_textureCoordinates);\n    if(currD.r>=1.0){\n      glColor = color;\n      return;\n    }\n    float depth = getDepth(currD);\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\n\n    // 从深度图计算法向量\n    vec3 dx = dFdx(positionEC.xyz);\n    vec3 dy = dFdy(positionEC.xyz);\n    vec3 nor = normalize(cross(dx,dy));\n    vec3 normalWC = normalize(czm_inverseViewRotation * nor);\n\n    float dotNumWC = dot(positionWC.xyz,normalWC);\n    if(dotNumWC<=0.3){\n      glColor = mix(color,vec4(1.0),alpha*0.3);\n      return;\n    }\n    glColor = mix(color,vec4(1.0),dotNumWC*alpha);\n  }",uniforms:{alpha:e}})}getSnowFlyPostProcess(e,t){return new this.Cesium.PostProcessStage({fragmentShader:"\n  uniform sampler2D colorTexture;\n  in vec2 v_textureCoordinates;\n  uniform float snowSpeed;\n  uniform float snowSize;\n  out vec4 glColor;\n  float snow(vec2 uv,float scale)\n  {\n      float time=czm_frameNumber/10000. *snowSpeed;\n      float w=smoothstep(1.,0.,-uv.y*(scale/10.));\n      if(w<.1)return 0.;\n      uv+=time/scale;\n      uv.y+=time*2./scale;\n      uv.x+=sin(uv.y+time*.5)/scale;\n      uv*=scale;\n      vec2 s=floor(uv),f=fract(uv),p;\n      float k=3.,d;\n      p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;\n      d=length(p);\n      k=min(d,k);\n      k=smoothstep(0.,k,sin(f.x+f.y)*snowSize);\n      return k*w;\n  }\n  void main(void){\n      vec2 resolution=czm_viewport.zw;\n      vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\n      vec3 finalColor=vec3(0);\n      //float c=smoothstep(1.,0.3,clamp(uv.y*.3+.8,0.,.75));\n      float c=0.;\n      c+=snow(uv,30.)*.0;\n      c+=snow(uv,20.)*.0;\n      c+=snow(uv,15.)*.0;\n      c+=snow(uv,10.);\n      c+=snow(uv,8.);\n      c+=snow(uv,6.);\n      c+=snow(uv,5.);\n      finalColor=(vec3(c));\n      glColor=mix(texture(colorTexture,v_textureCoordinates),vec4(finalColor,1),.1);\n      }\n  ",uniforms:{snowSpeed:e,snowSize:t}})}getVertexChangeHeightCustomShader(e){const t=e.map(((e,t)=>({key:`u_point${t}`,value:e})));let n={};t.forEach((e=>{n[e.key]={type:this.Cesium.UniformType.VEC3,value:e.value}})),n.u_height={type:this.Cesium.UniformType.FLOAT,value:100};let i=e.map(((e,t)=>`point[${t}] = czm_inverseModel * vec4(u_point${t}, 1.);\n`));return i=i.join(""),new this.Cesium.CustomShader({uniforms:n,vertexShaderText:`\n              // 判断点是否再多边形内的方法\n              bool pointInPolygon(vec3 p, vec4 points[${e.length}]){\n                bool inside = false;\n                const int length = ${e.length};\n                for (int i = 0; i < length; i++) {\n                  float xi = points[i].x;\n                  float zi = points[i].z;\n                  float xj;\n                  float zj;\n                  if (i == 0) {\n                    xj = points[length - 1].x;\n                    zj = points[length - 1].z;\n                  } else {\n                    xj = points[i - 1].x;\n                    zj = points[i - 1].z;\n                  }\n                  bool intersect = ((zi > p.z) != (zj > p.z)) && (p.x < (xj - xi) * (p.z - zi) / (zj - zi) + xi);\n                  if (intersect) {\n                    inside = !inside;\n                  }\n                }\n                  return inside;\n              }\n\n              void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {\n                // 将左上角点的世界坐标,转换为模型内部坐标\n                vec4 point[${e.length}];\n                // 将绘制的坐标 转换为模型坐标后 赋值到数组中, 判断函数要用\n                ${i}\n\n                // 计算第一个点的模型坐标的高度\n                vec4 point1MC = czm_inverseModel * vec4(u_point0,1.);\n                // 如果当前顶点在范围内,就把他的顶点高度设成第一个绘制点的模型顶点高度\n                if(pointInPolygon(vsOutput.positionMC,point)){\n                  vsOutput.positionMC.y = u_height;\n                }\n              }\n              `})}getTilesetDynamicShader(){return new this.Cesium.CustomShader({fragmentShaderText:"\n      void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {\n        // 渐变效果\n        vec4 position = czm_inverseModelView * vec4(fsInput.attributes.positionEC, 1); // 解算出模型坐标\n        // vec4 position = vec4(fsInput.attributes.positionMC,1); // 解算出模型坐标\n        float glowRange = 100.0; // 光环的移动范围(高度)，最高到200米\n        material.diffuse = vec3(0.2, 1.0, 1.0); // 基础蓝色\n        material.diffuse *= vec3(position.z / 100.0); // 按模型高度进行颜色变暗处理\n        // // 扫描线\n        float time = fract(czm_frameNumber / 180.0); // 计算当前着色器的时间，帧率/（6*60），即时间放慢6倍\n        // clamp 将值限制在0到1之间\n        float diff = step(0.005, abs(clamp(position.z / glowRange, 0.0, 1.0) - time)); // 根据时间来计算颜色差异，比例\n        material.diffuse.rgb += material.diffuse.rgb * (1.0 - diff); // 原有颜色加上颜色差异值提高亮度\n      }\n    "})}},TerrainClipPlan:a,CustomPrimitive:{DimondPrimitive:class{constructor({lon:e=118.79304711609575,lat:t=32.07511800768333,height:n=0,Cesium:i}){const r=i.Cartesian3.fromDegrees(e,t,n),a=i.Transforms.eastNorthUpToFixedFrame(r),l=[0,0,0],c=[[40,0,110],[40*Math.cos(i.Math.toRadians(60)),40*Math.sin(i.Math.toRadians(60)),110],[40*Math.cos(i.Math.toRadians(120)),40*Math.sin(i.Math.toRadians(120)),110],[40*Math.cos(i.Math.toRadians(180)),40*Math.sin(i.Math.toRadians(180)),110],[40*Math.cos(i.Math.toRadians(240)),40*Math.sin(i.Math.toRadians(240)),110],[40*Math.cos(i.Math.toRadians(300)),40*Math.sin(i.Math.toRadians(300)),110]],m=[[60,0,80],[60*Math.cos(i.Math.toRadians(60)),60*Math.sin(i.Math.toRadians(60)),80],[60*Math.cos(i.Math.toRadians(120)),60*Math.sin(i.Math.toRadians(120)),80],[60*Math.cos(i.Math.toRadians(180)),60*Math.sin(i.Math.toRadians(180)),80],[60*Math.cos(i.Math.toRadians(240)),60*Math.sin(i.Math.toRadians(240)),80],[60*Math.cos(i.Math.toRadians(300)),60*Math.sin(i.Math.toRadians(300)),80]];return s=(e,t)=>{const n={u_color:()=>i.Color.HONEYDEW},r=i.Buffer.createVertexBuffer({usage:i.BufferUsage.STATIC_DRAW,typedArray:new Float32Array([l,m[1],m[0],l,m[2],m[1],l,m[3],m[2],l,m[4],m[3],l,m[5],m[4],l,m[0],m[5],m[0],m[1],c[0],m[1],m[2],c[1],m[2],m[3],c[2],m[3],m[4],c[3],m[4],m[5],c[4],m[5],m[0],c[5],c[1],c[0],m[1],c[2],c[1],m[2],c[3],c[2],m[3],c[4],c[3],m[4],c[5],c[4],m[5],c[0],c[5],m[0],c[0],c[1],c[5],c[1],c[2],c[3],c[3],c[4],c[5],c[1],c[3],c[5]].flat(1)),context:e.context});function a(e){const t=i.Color.fromCssColorString(e);return[[t.red,t.green,t.blue],[t.red,t.green,t.blue],[t.red,t.green,t.blue]]}const o=i.Buffer.createVertexBuffer({usage:i.BufferUsage.STATIC_DRAW,typedArray:new Float32Array([a("#a6abbb"),a("#565d6a"),a("#898d93"),a("#c6c7d4"),a("#a6abbb"),a("#d8dee0"),a("#edf0f6"),a("#85a3c3"),a("#97a5b0"),a("#b6aeb4"),a("#6f757f"),a("#a6abbb"),a("#d3d8e0"),a("#6c7b83"),a("#93afcd"),a("#6b85a5"),a("#636d75"),a("#a6abbb"),a("#e7edf6"),a("#a9b4ba"),a("#a3a9a9"),a("#a6abbb")].flat(2)),context:e.context}),s=new i.VertexArray({context:e.context,attributes:[{index:0,vertexBuffer:r,componentsPerAttribute:3,componentDatatype:i.ComponentDatatype.FLOAT},{index:1,vertexBuffer:o,componentsPerAttribute:3,componentDatatype:i.ComponentDatatype.FLOAT}]}),u=i.ShaderProgram.fromCache({context:e.context,vertexShaderSource:"\n            in vec3 a_color;\n            in vec3 position;\n            \n            out vec3 o_color;\n            void main() {\n              vec3 positonTemp = position;\n              // 高度上下跳跃\n              positonTemp.z += abs(sin(czm_frameNumber*10. /1000.0)) * 30.;\n              // 旋转\n              positonTemp.x = position.x * cos(czm_frameNumber*3. /1000.0) - position.y * sin(czm_frameNumber*3. /1000.0);\n              positonTemp.y = position.x * sin(czm_frameNumber*3. /1000.0) + position.y * cos(czm_frameNumber*3. /1000.0);\n              gl_Position = czm_projection * czm_view * czm_model * vec4(positonTemp, 1.0);\n              o_color = a_color;\n            }",fragmentShaderSource:"\n            uniform vec3 u_color;\n            in vec3 o_color;\n            out vec4 fsOutput;\n            void main(){\n              // 变色钻石\n              fsOutput = vec4(abs(cos(czm_frameNumber*3./1000.)),o_color.y,fract(cos(czm_frameNumber*3./1000.)),1.0);\n              // fsOutput = vec4(o_color,1.0);\n            }",attributeLocations:{position:0,a_color:1}}),p=i.RenderState.fromCache({depthTest:{enabled:!0},cull:{enabled:!0,face:i.CullFace.BACK}});return new i.DrawCommand({modelMatrix:t,vertexArray:s,shaderProgram:u,uniformMap:n,renderState:p,pass:i.Pass.OPAQUE})},new o(a)}}}}})(),r})()));